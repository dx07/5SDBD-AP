{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "from config import setup\n",
    "setup()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "import json\n",
    "import networkx as nx\n",
    "from docplex.cp.model import CpoModel\n",
    "from docplex.cp.model import *\n",
    "\n",
    "# Comme on ne peut pas définir la longueur d'un arc à partir des fichiers générés ...\n",
    "VALEUR_ARBITRAIRE_ARC_SORTIE = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4455, 70, 68]\n",
      "[509, 70, 22]\n",
      "[4584, 71, 128]\n",
      "[2902, 71, 122]\n",
      "[2808, 71, 84]\n",
      "[2744, 70, 22]\n",
      "[3982, 3982, 50]\n",
      "[1471, 70, 122]\n",
      "[1783, 71, 22]\n",
      "[358, 70, 68]\n",
      "[71, [[1, 0], [8, 0]]]\n",
      "[224, [[2, 17], [4, 35], [5, 30]]]\n",
      "[70, [[1, 3], [6, 3], [8, 3]]]\n",
      "[132, [[4, 29], [5, 24]]]\n",
      "[132, [[0, 0], [3, 8], [9, 0]]]\n",
      "[249, [[0, 18], [1, 23], [2, 30], [3, 26], [4, 48], [5, 43], [6, 23], [8, 23], [9, 18]]]\n",
      "[132, [[3, 8], [9, 0]]]\n",
      "[146, [[0, 1], [1, 6], [3, 9], [6, 6], [8, 6], [9, 1]]]\n"
     ]
    }
   ],
   "source": [
    "def read_evac(filename):\n",
    "    \n",
    "    with open(filename,\"r\") as file:\n",
    "        content = file.readlines()\n",
    "    \n",
    "    if len(content) > 0:\n",
    "        \n",
    "        nbzones, nbarcs = content[0].split(\" \")\n",
    "        content.remove(content[0])\n",
    "    \n",
    "        lineszones = content[0:int(nbzones)]\n",
    "        linesarcs  = content[int(nbzones):int(nbzones)+int(nbarcs)]\n",
    "        \n",
    "        E = []\n",
    "        \n",
    "        for line in lineszones:\n",
    "            personnes, paquets, datemax = line.split(\" \")\n",
    "            E.append([int(personnes),int(paquets),int(datemax)])\n",
    "            \n",
    "        A = []\n",
    "        \n",
    "        for line in linesarcs:\n",
    "            \n",
    "            content = line.split(\" \")\n",
    "            capacite = content[0]\n",
    "            content = content[2:]\n",
    "            \n",
    "            groups = []\n",
    "            \n",
    "            for i in range(0,len(content),2):\n",
    "                numgroupe = content[i]\n",
    "                datemax = content[i+1]\n",
    "                \n",
    "                groups.append([int(numgroupe),int(datemax)])\n",
    "                \n",
    "            A.append([int(capacite),groups])\n",
    "            \n",
    "        return E,A\n",
    "        \n",
    "        \n",
    "# import os\n",
    "# os.listdir()\n",
    "\n",
    "E,A = read_evac(\"evacsim-master/data/test_10_25_2_10.evac\")\n",
    "\n",
    "print(*E, sep = \"\\n\")\n",
    "print(*A, sep = \"\\n\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[\n",
      " [\n",
      "  [\n",
      "   [\n",
      "    0,\n",
      "    4455,\n",
      "    70,\n",
      "    68,\n",
      "    64,\n",
      "    [\n",
      "     [\n",
      "      4,\n",
      "      0\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      1\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      18\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    1,\n",
      "    509,\n",
      "    70,\n",
      "    22,\n",
      "    8,\n",
      "    [\n",
      "     [\n",
      "      0,\n",
      "      0\n",
      "     ],\n",
      "     [\n",
      "      2,\n",
      "      3\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      6\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      23\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    2,\n",
      "    4584,\n",
      "    71,\n",
      "    128,\n",
      "    65,\n",
      "    [\n",
      "     [\n",
      "      1,\n",
      "      17\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      30\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    3,\n",
      "    2902,\n",
      "    71,\n",
      "    122,\n",
      "    41,\n",
      "    [\n",
      "     [\n",
      "      4,\n",
      "      8\n",
      "     ],\n",
      "     [\n",
      "      6,\n",
      "      8\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      9\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      26\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    4,\n",
      "    2808,\n",
      "    71,\n",
      "    84,\n",
      "    40,\n",
      "    [\n",
      "     [\n",
      "      3,\n",
      "      29\n",
      "     ],\n",
      "     [\n",
      "      1,\n",
      "      35\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      48\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    5,\n",
      "    2744,\n",
      "    70,\n",
      "    22,\n",
      "    40,\n",
      "    [\n",
      "     [\n",
      "      3,\n",
      "      24\n",
      "     ],\n",
      "     [\n",
      "      1,\n",
      "      30\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      43\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    6,\n",
      "    3982,\n",
      "    3982,\n",
      "    50,\n",
      "    1,\n",
      "    [\n",
      "     [\n",
      "      2,\n",
      "      3\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      6\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      23\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    7,\n",
      "    1471,\n",
      "    70,\n",
      "    122,\n",
      "    22,\n",
      "    [],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    8,\n",
      "    1783,\n",
      "    71,\n",
      "    22,\n",
      "    26,\n",
      "    [\n",
      "     [\n",
      "      0,\n",
      "      0\n",
      "     ],\n",
      "     [\n",
      "      2,\n",
      "      3\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      6\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      23\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ],\n",
      "   [\n",
      "    9,\n",
      "    358,\n",
      "    70,\n",
      "    68,\n",
      "    6,\n",
      "    [\n",
      "     [\n",
      "      4,\n",
      "      0\n",
      "     ],\n",
      "     [\n",
      "      6,\n",
      "      0\n",
      "     ],\n",
      "     [\n",
      "      7,\n",
      "      1\n",
      "     ],\n",
      "     [\n",
      "      5,\n",
      "      18\n",
      "     ]\n",
      "    ],\n",
      "    null\n",
      "   ]\n",
      "  ],\n",
      "  [\n",
      "   10,\n",
      "   11,\n",
      "   13\n",
      "  ],\n",
      "  [\n",
      "   12\n",
      "  ]\n",
      " ],\n",
      " [\n",
      "  [\n",
      "   0,\n",
      "   71,\n",
      "   1,\n",
      "   13,\n",
      "   3\n",
      "  ],\n",
      "  [\n",
      "   1,\n",
      "   224,\n",
      "   2,\n",
      "   11,\n",
      "   13\n",
      "  ],\n",
      "  [\n",
      "   2,\n",
      "   70,\n",
      "   13,\n",
      "   10,\n",
      "   3\n",
      "  ],\n",
      "  [\n",
      "   3,\n",
      "   132,\n",
      "   4,\n",
      "   2,\n",
      "   6\n",
      "  ],\n",
      "  [\n",
      "   4,\n",
      "   132,\n",
      "   0,\n",
      "   10,\n",
      "   1\n",
      "  ],\n",
      "  [\n",
      "   5,\n",
      "   249,\n",
      "   11,\n",
      "   12,\n",
      "   1\n",
      "  ],\n",
      "  [\n",
      "   6,\n",
      "   132,\n",
      "   3,\n",
      "   10,\n",
      "   1\n",
      "  ],\n",
      "  [\n",
      "   7,\n",
      "   146,\n",
      "   10,\n",
      "   11,\n",
      "   17\n",
      "  ]\n",
      " ]\n",
      "]\n"
     ]
    }
   ],
   "source": [
    "def graph2list(filename):\n",
    "    \n",
    "    E,A = read_evac(\"evacsim-master/data/test_10_25_2_10.evac\")\n",
    "    \n",
    "    ########################## TRAITEMENT DES SOMMETS ##########################\n",
    "    \n",
    "    new_E = [] # Ensemble de sommets à évacuer\n",
    "    \n",
    "    for i_k in range(len(E)):\n",
    "        w_k, h_k, d_k = E[i_k]\n",
    "        p_k = math.ceil(w_k / h_k)\n",
    "        A_k = []\n",
    "        s_k = None\n",
    "        \n",
    "        k = [\n",
    "            i_k,  # Identifiant du sommet\n",
    "            w_k,  # Nombre de personnes à évacuer\n",
    "            h_k,  # Taux d'évacuation d'un sommet\n",
    "            d_k,  # Date à laquelle le sommet crame\n",
    "            p_k,  # Durée d'évacuation d'un sommet\n",
    "            A_k,  # Liste des sommets pour le chemin d'évacuation\n",
    "            s_k,  # Date début évacuation d'un sommet\n",
    "        ]\n",
    "        \n",
    "        new_E.append(k)\n",
    "        \n",
    "    ########################## TRAITEMENT DES ARCS ##########################\n",
    "    \n",
    "    new_A = []\n",
    "    \n",
    "    for i_e in range (len(A)):\n",
    "        c_e, groups = A[i_e]\n",
    "        in_e = None\n",
    "        out_e = None\n",
    "        l_e = None\n",
    "\n",
    "        for i_k, b_e in groups:\n",
    "            \n",
    "            e = [    # Arc d'un chemin d'évacuation d'un sommet\n",
    "                i_e, # Identifiant de l'arc\n",
    "                b_e, # Date min de passage\n",
    "            ]\n",
    "            \n",
    "            k = new_E[i_k]\n",
    "            A_k = k[5]\n",
    "            \n",
    "            if len(A_k) == 0:\n",
    "                A_k.append(e)\n",
    "            else:\n",
    "                added = False\n",
    "                for i in range (len(A_k)):\n",
    "                    if A_k[i][1] > e[1]:\n",
    "                        A_k.insert(i,e)\n",
    "                        added = True\n",
    "                if added == False:\n",
    "                    A_k.append(e)\n",
    "            \n",
    "            k[5] = A_k\n",
    "            new_E[i_k] = k\n",
    "\n",
    "        e = [\n",
    "            i_e,     # Identifiant de l'arc\n",
    "            c_e,     # Capacité de l'arc en personnes par unité de temps\n",
    "            in_e,    # Identifiant du sommet entrant\n",
    "            out_e,   # Identifiant du sommet sortant\n",
    "            l_e,     # Longueur de l'arc\n",
    "        ]\n",
    "        \n",
    "        new_A.append(e)\n",
    "        \n",
    "    ####################### IDENIFICATION DES SOMMETS #######################\n",
    "    \n",
    "    # Cette partie va servir à trouver et compléter la liste des sommets\n",
    "    # intermédiaires et de sortie, tout en complétant les in/out des arcs\n",
    "        \n",
    "    new_T = [] # Ensemble de sommets de transfert\n",
    "    new_S = [] # Ensemble de sommets séurisés\n",
    "    \n",
    "    k_sommets = len(new_E)\n",
    "    k_arcs = []\n",
    "    \n",
    "    for k in new_E:\n",
    "        A_k = k[5]\n",
    "        parcours = k[0]\n",
    "        for i in range (len(A_k)):\n",
    "            e = new_A[A_k[i][0]]\n",
    "            \n",
    "            if e[0] in k_arcs:\n",
    "                \n",
    "                #Arc connu donc rien à faire\n",
    "                continue\n",
    "            \n",
    "            else:\n",
    "                \n",
    "                #On ajoute le sommet d'entrée de l'arc\n",
    "                e[2] = parcours\n",
    "                \n",
    "                #On ajoute l'arc aux arc parcourus\n",
    "                k_arcs.append(e[0])\n",
    "                \n",
    "                #Contrôle de l'arc suivant\n",
    "                if i+1 < len(A_k):\n",
    "\n",
    "                    #Il y a bien un arc suivant, on a affaire à un sommet intermédiaire\n",
    "                    e_suiv = new_A[A_k[i+1][0]]\n",
    "                    \n",
    "                    #On peut donc connaître la longueur de l'arc\n",
    "                    e[4] = A_k[i+1][1] - A_k[i][1]\n",
    "\n",
    "                    if e_suiv[0] in k_arcs:\n",
    "\n",
    "                        #Arc connu donc on connait son entrée, donc celui de sortie de l'arc actuel\n",
    "                        e[3] = e_suiv[2]\n",
    "\n",
    "                    else:\n",
    "\n",
    "                        #Arc inconnu donc on a découvert un nouveau sommet intermédiaire\n",
    "                        e[3] = k_sommets\n",
    "                        new_T.append(k_sommets)\n",
    "                        k_sommets += 1\n",
    "\n",
    "                    #On prépare le sommet de départ pour le prochain arc\n",
    "                    parcours = e[3]\n",
    "\n",
    "                else:\n",
    "\n",
    "                    #Pas de sommet suivant donc on a atteint un sommet de sécurité\n",
    "                    e[3] = k_sommets\n",
    "                    new_S.append(k_sommets)\n",
    "                    k_sommets += 1\n",
    "                    \n",
    "                    #On ne peut donc pas connaître la longueur de l'arc, on la met arbitraitement à 1\n",
    "                    e[4] = VALEUR_ARBITRAIRE_ARC_SORTIE\n",
    "                        \n",
    "                #Mise à jour de e\n",
    "                new_A[e[0]] = e\n",
    "                \n",
    "    # TODO Bug sur le sommet 3 et arc 6 (qui a la même date au plus tôt que l'arc 4)\n",
    "    # On fait le choix de l'ignorer pour le moment, on a quand même un graphe utilisable\n",
    "            \n",
    "    ########################## TRAITEMENT DU GRAPHE ##########################\n",
    "    \n",
    "    X = [       # Ensemble des sommets du graphe\n",
    "        new_E,  # Ensemble de sommets à évacuer\n",
    "        new_T,  # Ensemble de sommets de transfert\n",
    "        new_S,  # Ensemble de sommets séurisés\n",
    "    ]\n",
    "    \n",
    "    G = [       # Notre graphe\n",
    "        X,      # Ensemble des sommets du graphe\n",
    "        new_A,  # Ensemble des arêtes du graphe\n",
    "    ]\n",
    "    \n",
    "    return G\n",
    "\n",
    "G_list = graph2list(\"projet/evacsim-master/data/test_10_25_2_10.evac\")\n",
    "\n",
    "print(json.dumps(G_list, indent=1))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "def list2geosafe(G_list):\n",
    "    \n",
    "    nodes_state = []\n",
    "    edges_state = []\n",
    "    \n",
    "    for eps in G_list[0][0]:\n",
    "        nodes_state.append((eps[0], {'eps': True,  'r': False, 'W': eps[1], 'd': eps[3]}))\n",
    "        \n",
    "    for trans in G_list[0][1]:\n",
    "        nodes_state.append((trans, {'eps': False,  'r': False, 'W': 0, 'd': 0}))\n",
    "        \n",
    "    for r in G_list[0][2]:\n",
    "        nodes_state.append((r, {'eps': False,  'r': True, 'W': 0, 'd': 0}))\n",
    "        \n",
    "    for edge in G_list[1]:\n",
    "        edges_state.append((edge[2], edge[3], {'l' : edge[4]}))\n",
    "    \n",
    "    G = nx.DiGraph()\n",
    "    G.add_nodes_from(nodes_state)\n",
    "    G.add_edges_from(edges_state)\n",
    "    \n",
    "    return G\n",
    "        \n",
    "G = list2geosafe(G_list)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
